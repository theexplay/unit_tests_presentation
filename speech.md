# Unit тестирование

### Тестирование приложений. Слайд 2
Вы можете рассматривать тесты как гарантии надёжности ваших приложений. Они будут запускаться не только на вашей локальной машине, но и на CI-сервисах, чтобы сломанные сборки не попадали в продакшен.

Автоматические тесты дают уверенность, что ваша программа работает как задумано. Такие тесты можно запускать многократно. Успешное выполнение тестов покажет разработчику, что его изменения не сломали ничего, что ломать не планировалось.

Провалившийся тест позволит обнаружить, что в коде сделаны изменения, которые меняют или ломают его поведение. Исследование ошибки, которую выдает провалившийся тест, и сравнение ожидаемого результата с полученным даст возможность понять, где возникла ошибка, будь она в коде или в требованиях.

Также принято считать «Тесты — это больше, чем просто гарантии, они обеспечивают живую документацию для вашей кодовой базы».

### Слайд 3
Вы можете спросить: что я должен протестировать в своём приложении? Сколько тестов у меня должно быть?

Ответ варьируется, но, как правило, вы можете следовать рекомендациям, установленным пирамидой тестирования.

По сути, тестовая пирамида описывает, что вы должны писать модульные тесты, интеграционные тесты и e2e тесты. У вас должно быть больше интеграционных тестов, чем e2e и ещё больше модульных тестов.

### Слайд 4
- Модульные тесты реализовывать быстрее, чем GUI тесты (время на разработку меньше). Модульные тесты отрабатывают быстрее, чем GUI.
- Модульные тесты дешевле, чем GUI тесты (однако, стремясь к вершине пирамиды, мы получаем большую уверенность в том, что все работает как ожидалось).
- Тестирование должно быть разносторонним, но соотношение тестов должно быть таково, что модульных количественно больше, чем GUI. Системные тесты занимают золотую середину.

Автоматизированное тестирование – это когда тесты написаны отдельно от кода, и можно в любой момент запустить их и проверить все важные случаи использования.

Все вышесказанное справедливо для любых тестов. Там даже не упомянуты юнит-тесты как таковые. Итак, в чем же их отличие?

### Слайд 5
В двух словах о типах тестирования
- Unit Tests -  Ответ кроется в названии: «юнит» означает, что мы тестируем не всю систему в целом, а небольшие ее части. Функцию, класс, метод.  Мы подменяем, подставляем (мокаем) входные данные и проверяем что выходные данные правильные.
- Integration Tests - тестируем совместную работу нескольких модулей (групп) согласно нашим ожиданиям.
- Functional Tests - Функциональное тестирование — тестирование некого функционала продукта, при этом продукт воспринимается как единый «чёрный ящик».

Также существуют разные подходы (методологии, структуры) BDD (Behaviour Driven Development), TDD (Test Driven Development).
Эта Тема слишком большая, у каждой есть свои плюсы и минусы, рекоендую почитать подробнее о каждом из подходов. 
Тесты BDD – это три в одном: И тесты, И документация, И примеры использования.

### Слайд 6
Каждый модульный тест имеет следующую структуру:

- Настройка теста
- Вызов тестируемого метода
- Утверждение
Один тест тестирует ровно одну вещь.

Если мы явно видим, что тест включает в себя совершенно независимые проверки – лучше разбить его на два более простых и наглядных.

### Слайд 7
Ещё до разработки мы можем представить себе, что эта функция будет делать, и описать это по методике BDD.
Это описание называется спецификация (или, как говорят в обиходе, «спека»).

У спецификации есть три основных строительных блока, которые вы видите в примере выше:
`describe(название, function() { ... })`
Задаёт, что именно мы описываем, используется для группировки «рабочих лошадок» – блоков it. В данном случае мы описываем функцию pow.

`it(название, function() { ... })`
В названии блока it человеческим языком описывается, что должна делать функция, далее следует тест, который проверяет это.

`expect(sum).toBe(5);`
Код внутри it, если реализация верна, должен выполняться без ошибок.

Различные функции вида `expect()` используются, чтобы проверить, делает ли pow то, что задумано. 
Есть и другие виды сравнений и проверок.

### Слайд 8
Инструменты для тестирования.

Здесь я представил вам небольшой список фремворков, библиотек, инструментов для тестирования.
К примеру, мы можем настроить базовое тестовое окружение, задать структуру тестов, способ "сравнивания", генерация и просмотр документа о покрытии тестами проекта, создание snapshots компонентов и их структуры относительно прошлого запуска тестов, шпионы, табы, моки и браузероподобный инструмент для тестирования

Так что выбрать фреймворк и тулзы для тестирования довольно непросто, но вы можете прочитать про это подробнее, в конце будут ссылки на статьи.


### Слайд 9
Шпионы, стабы и моки — что использовать и когда?
Прежде чем приступить к практике модульного тестирования, давайте разберёмся, что такое шпионы, стабы (заглушки) и моки!

### Слайд 10
Вы можете использовать шпионов для получения информации о вызовах функций, например, сколько раз они были вызваны или какие аргументы были им переданы.

### Слайд 11
Стабы похожи на шпионов, но они заменяют целевую функцию. Вы можете использовать стабы для управления поведением метода, чтобы форсировать какие-то события в коде (например, выброс ошибки) или предотвратить вызовы внешних ресурсов (таких как HTTP API).


### Слайд 13
Моки — это поддельные методы с заранее запрограммированным поведением и соглашениями.

### Слайд 15
Покрытие кода

Чтобы лучше понять, насколько хорошо ваша кодовая база покрыта тестами, вы можете сгенерировать отчёт о покрытии.

Этот отчёт будет включать следующие метрики:
- покрытие строк кода,
- покрытие инструкций,
- покрытие ветвлений,
- и покрытие функций.

Вы можете кликнуть мышью и на самом деле увидеть, что ваш исходный код аннотирован: какая часть протестирована, а какая — нет.

### Слайд 16
Дальше для примеров я буду использовать Jasmine.js так как уже работал с ним, а также он из коробки содержит необходимые инструменты: окружение для запуска, структура, отчёты о покрытии, способ "сравнения" (assertion) и мокание.
Но, никто не запрещает заменить какой либо из встроенных инструментов на какой-либо другой, который вам больше по душе.

### Слайд 17
Тестирование может уберечь вас от множества неприятностей.
Даже если какое-то изменение потенциально может порушить всё – его совершенно не страшно сделать. Ведь есть масса тестов, которые быстро и в автоматическом режиме проверят работу кода. И если что-то падает, то это можно будет легко локализовать и поправить.

Единственное что хотелось бы добавить, что только одного unit тестирования недостаточно. 
